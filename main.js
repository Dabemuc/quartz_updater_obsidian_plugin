/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";var R=Object.create;var m=Object.defineProperty;var F=Object.getOwnPropertyDescriptor;var O=Object.getOwnPropertyNames;var $=Object.getPrototypeOf,j=Object.prototype.hasOwnProperty;var z=(s,a)=>{for(var t in a)m(s,t,{get:a[t],enumerable:!0})},U=(s,a,t,e)=>{if(a&&typeof a=="object"||typeof a=="function")for(let n of O(a))!j.call(s,n)&&n!==t&&m(s,n,{get:()=>a[n],enumerable:!(e=F(a,n))||e.enumerable});return s};var M=(s,a,t)=>(t=s!=null?R($(s)):{},U(a||!s||!s.__esModule?m(t,"default",{value:s,enumerable:!0}):t,s)),C=s=>U(m({},"__esModule",{value:!0}),s);var B={};z(B,{default:()=>b});module.exports=C(B);var o=require("obsidian"),P=require("crypto"),q=M(require("path")),L=M(require("fs")),A={backendUrl:""},b=class extends o.Plugin{constructor(){super(...arguments);this.settings=A}async onload(){await this.loadSettings();let t=this.addRibbonIcon("folder-sync","Quartz Sync",e=>{new S(this.app,this.settings).open()});this.addCommand({id:"open-quartz-sync-modal",name:"Open quartz sync modal",callback:()=>{new S(this.app,this.settings).open()}}),this.addSettingTab(new w(this.app,this))}onunload(){}async loadSettings(){this.settings=Object.assign({},A,await this.loadData())}async saveSettings(){this.settings.backendUrl.endsWith("/")&&(this.settings.backendUrl=this.settings.backendUrl.slice(0,-1)),await this.saveData(this.settings)}},r="not-started",f="",u="",S=class extends o.Modal{constructor(t,e){super(t);this.hashContent=t=>(0,P.createHash)("sha256").update(t).digest("hex");this.settings=e}onOpen(){let{contentEl:t}=this,e=t.createDiv("quartz-sync-modal");e.createEl("h2",{text:"Quartz Sync"}),e.createEl("p",{text:"This will attempt to sync all files marked with the quartz-sync=true frontmatter to the configured quartz_updater backend."});let n=e.createEl("button",{text:"Start sync"});e.createEl("h3",{text:"Sync status:"});let h=e.createEl("p",{text:r});e.createEl("h3",{text:"Client manifest generated:"});let d=e.createEl("p",{text:"..."});e.createEl("h3",{text:"Server response:"});let y=e.createEl("p",{text:"..."});n.addEventListener("click",()=>this.handleSync(h,n,y,d))}async handleSync(t,e,n,h){this.startStatusUpdate(t,e),f="",u="",r="started";try{if(!this.settings.backendUrl||this.settings.backendUrl==="")throw new Error("Backend URL is not set");let d=this.app.vault.getFiles().filter(i=>{var c;let l=(c=this.app.metadataCache.getFileCache(i))==null?void 0:c.frontmatter;return l&&l["quartz-sync"]==="true"});h.innerText=`Files to sync: 
 ${d.map(i=>i.path).join(`
`)}`;let y=d.map(i=>{let l=q.join(__dirname,i.path);h.innerText+=`
 Building manifest for ${l}`;let c=L.readFileSync(l,"utf-8").toString();h.innerText+=`
 File content: 
 ${c}`;let k=this.hashContent(c);return{path:i.path,hash:k}});r="manifest-built",h.innerText+=`
 Generated Manifest: 
 ${JSON.stringify(y)}`;let T=await fetch(this.settings.backendUrl+"/request-update",{method:"POST",mode:"cors",headers:{Accept:"application/json","Content-Type":"application/json"},body:JSON.stringify({manifest:y})});r="manifest-sent";let g=await T.json();if(n.innerText=JSON.stringify(g),T.status!==200)throw new Error("An Error occurred while sending the manifest");if(!g.body||!g.body.updateSessions)throw new Error("Response body is invalid");let x=g.body.updateSessions;if(!Array.isArray(x))throw new Error("Update sessions not found in response body");r="update-sessions-received",n.innerText="",await Promise.all(x.map(async i=>{let l=await Promise.all(i.permittedChanges.map(async p=>{let E=this.app.vault.getAbstractFileByPath(p.path);if(!(E instanceof o.TFile))throw new Error(`File ${p.path} could not be read`);return{type:p.type,path:p.path,content:await this.app.vault.read(E)}})),c=await fetch(this.settings.backendUrl+"/update-batch",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({id:i.id,updates:l})});if(n.innerText=n.innerText+`
`+i.id+`: 
`+JSON.stringify(await c.json()),c.status!==200)throw new Error("An Error occurred while sending updates");let v=(await c.json()).body;if(!Array.isArray(v))throw new Error("Invalid response body");v.forEach(p=>{u+=`${p.path}: ${p.status}
`})})),r="results-received"}catch(d){f=`Message: ${d.message} 
Stack: ${d.stack} 
Error: ${d}`,r="error"}}async startStatusUpdate(t,e){let n=setInterval(()=>{switch(t.innerText=r,r){case"started":t.innerText="Sending manifest",e.setAttribute("disabled","true"),e.innerText="Syncing...";break;case"manifest-sent":t.innerText="Waiting for update sessions";break;case"update-sessions-received":t.innerText=u;break;case"results-received":t.innerText=u,t.style.color="green",clearInterval(n),e.removeAttribute("disabled"),e.innerText="Restart sync";break;case"error":t.innerText=f,t.style.color="red",clearInterval(n),e.removeAttribute("disabled"),e.innerText="Restart sync";break}},1e3)}onClose(){let{contentEl:t}=this;t.empty(),r="not-started",f="",u=""}},w=class extends o.PluginSettingTab{constructor(t,e){super(t,e);this.plugin=e}display(){let{containerEl:t}=this;t.empty(),new o.Setting(t).setName("Backend URL").setDesc("URL of the quartz_updater backend").addText(e=>e.setPlaceholder("Required!").setValue(this.plugin.settings.backendUrl).onChange(async n=>{this.plugin.settings.backendUrl=n,await this.plugin.saveSettings()}))}};
